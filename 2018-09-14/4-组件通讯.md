# 组件通讯

## 基础

组件之间的 **数据传递**、**事件传递** 即为 **组件通讯**

## 父子组件

### $refs

```js
this.$refs["ref_name"]
this.$refs["ref_name"].$options.name
this.$refs["ref_name"].data_attribute
this.$refs["ref_name"].function_name
```

### $children

```js
this.$children[0]
this.$children[0].$options
this.$children[0].data_attribute
this.$refs[0].function_name
```

### $parent

```js
this.$parent
this.$parent.$data
this.$parent.data_attribute
this.$parent.function_name
```

### prop

- camelCase vs kebab-case

```html
<!-- HTML 特性名称不区分大小写 -->
<!-- 最终 data-blogId 会转换成 data-blogid -->
<div data-blogId="1"></div>
<div data-blogid="1"></div>
```

```js
// 因此当你在子组件中声明一个 cameClass 的 prop 时
Vue.component("blog-post", {
    // 在 JS 中 prop 是 cameClass 的
    props: ["blogId"],
    template: "<div>{{ blogTitle }}</div>"
})
```

```html
<!-- 在 HTML 中是 kebab-case 的 -->
<blog-post blog-id="1"></blog-post>
```

- 传递静态、动态的 prop

```html
<!-- 静态的传递, 此时传递为 prop 数据类型为 String -->
<blog-post blog-id="1"></blog-post>
<!-- 动态的传递, 此时传递的 prop 数据类型与父组件中定义的数据类型一致 -->
<blog-post v-bind:blog-id="PARENT_COMPONENT_DATA_ATTRIBUTE"></blog-post>
```

### $attrs

```html
<!-- In Parent Component -->
<child-component data-abc="parent-attr-data"></child-component>
```

```js
// In Child Component
Vue.component("child-component", {
    template: "<div>{{ blogTitle }}</div>"
    // 不使用 prop 接收 data-abc
    mounted: function() {
        console.log(this.$attrs); // => {"data-abc": "parent-attr-data"}
    }
})
// 类似: 获取 DOM 对象后,获取特性名称对应的值
// $node.attr('data-abc');
```

### 双向绑定

- 父组件传递 prop 时, 添加 .sync 修饰符
```html
<!-- 详见 ChildTree.vue -->
<child-component :blog-id.sync="blog.id"></child-component>
```
- 子组件通过特殊的 update $emit 通知父组件更新相应的 prop
```js
Vue.component("child-component", {
    props: ["blogId"],
    data: function() {
        // 1. 声明一个 prop 副本
        id: this.blogId
    },
    watch: {
        // 2. 观察 prop, prop 变化时, 更新副本
        blogId(val){
            this.id = val
        },
        // 3. 观察 副本, 副本变化时, 通知父组件更新 prop
        id(val){
            this.$emit("update:blogId", val)
        }
    }
})
```


## 兄弟 & 祖孙组件通讯

- eventBus
```js
// 中央事件总线,就是一个空的 Vue 实例
const eventBus = new Vue();
```

```js
// child-two 组件通过 eventBus.$emit() 传递 "child-two-click" 事件
Vue.component("child-two", {
    template: "<div @click='click'>child-tow</div>",
    methods: {
        click: function(){
            eventBus.$emit("child-two-click", "child two say 'hi' to child one")
        }
    }
})

// 兄弟组件 child-one 通过 eventBus.$on() 监听 "child-two-click" 事件
Vue.component("child-one", {
    template: "<div>child-one</div>",
    mounted: function(){
        eventBus.$on("child-two-click", function(msg_from_child_one){
            console.log(msg_from_child_one); // => child two say 'hi' to child one
        })
    }
})
```

## 实战

- EOS 采购计划单详情

![采购计划单商品](images/01.png)

![已选仓库商品](images/02.png)

- 业务需求

1. 搜索按钮点击, 获取数据, 当前页重置为第一页

2. 当前页变化时, 获取当前页数据

3. 自动分仓按钮点击, 服务端处理成功后, Tabs 切换至右侧, 右侧需重新渲染数据

4. 生成采购单按钮点击, 服务端处理成功后, 跳转至采购单相应页面

- 拆分视图

1. Tabs 标签 => 公共组件

2. Form 搜索表单 => 公共组件 (左侧独有: **自动分仓**, 右侧独有: **生成采购单**)

3. Product 商品数据列表 => 独有组件 (包含分页组件)

4. Pagination 分页 => 公共组件(这里直接使用 iview Page 组件, 因此没有单独封装)

- 拆分组件

```shell
- views/                                    # 视图组件根目录

    - purchasePlan/                         # 采购计划单根目录

        - Detail.vue                        # 采购计划单详情视图组件 Tabs

        - detail-components/                # 详情视图组件 子组件根目录

            - DetailForm.vue                # 搜索表单 Form

            - DetailLeft.vue                # 左 Tabs 容器

            - DetailLeftProduct.vue         # 商品列表 Product

            - DetailRight.vue               # 右 Tabs 容器

            - DetailRightProduct.vue        # 商品列表 Product
```

- 设计层级

    1. 通过 ```<component></component>``` 完成 Tab 切换效果
    2. Form 可以复用, 通过 ```<slot></slot>``` 完成左右两边独有按钮业务逻辑

```html
<detail>
    <!--
        通过 <component :is="currentComponent"></component>
        动态挂载 <detail-left></detail-left> or <detail-right></detail-right>
    -->
    <detail-left>
        <detail-form>
            <template slot="extra-buttons">
                <button>自动分仓</button>
            </template>
        </detail-form> 
        <detail-left-product></detail-left-product>
    </detail-left>
    <detail-right>
        <detail-form>
            <template slot="extra-buttons">
                <button>生成采购单</button>
            </template>
        </detail-form> 
        <detail-right-product></detail-right-product>
    </detail-right>
</detail>
```

- 设计通讯

    1. 自动分仓 操作成功时, Tab 切换至右侧
    
    因为自动分仓按钮是由 slot 分发的, 因此其仍然处于 ```DetailLeft.vue``` 作用域内,因此, 这一步的通讯, 其实是 ```Detail.vue``` 与 ```DetailLeft.vue``` 父子组件中的通讯, 我们直接使用 $emit 即可

- Detail.vue

1. 使用 Vuejs 内置组件: ```<component></component>``` 的 ```is``` 进行容器组件的动态挂载 

2. 使用 Vuejs 内置组件: ```<keep-alive></keep-alive>``` 避免左右容器组件重复渲染

3. 这取决于实际业务场景, 这里只是介绍 keep-alive 使用

```html
<template>
  <div>
    <button 
        v-for="tab in tabs" 
        :key="tab.value" 
        :class="['tab-button', { active: currentTab === tab.value }]" 
        @click="currentTab = tab.value">
        {{ tab.label }}
    </button>

    <keep-alive>
        <component
            :is="$currentTabComponent" 
            <!--自动分仓通讯-->
            @on-auth-split="currentTab = 'right'">
        </component>
    </keep-alive>
  </div>
</template>
```

```js
import DetailLeft from "./detail-components/DetailLeft.vue";
import DetailRight from "./detail-components/DetailRight.vue";
export default {

    components: {
        "detail-left": DetailLeft,
        "detail-right": DetailRight,
    },

    data() {
        return {
            currentTab: "left",
            tabs: [
                {
                    value: "left",
                    label: "采购计划商品"
                },
                {
                    value: "right",
                    label: "已选仓库商品"
                }
            ],
        };
    },

    computed: {
        $currentTabComponent() {
            return `detail-${this.currentTab}`;
        }
    },

};
```

